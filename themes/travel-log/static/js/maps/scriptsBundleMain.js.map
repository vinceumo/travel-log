{"version":3,"sources":["themes/travel-log/src/js/vendors/inert.js","themes/travel-log/src/js/customs/navigation.js"],"names":["_classCallCheck","instance","Constructor","TypeError","composedTreeWalk","node","callback","shadowRootAncestor","nodeType","Node","ELEMENT_NODE","element","shadowRoot","webkitShadowRoot","localName","content","distributedNodes","getDistributedNodes","i","length","slot","assignedNodes","flatten","child","firstChild","nextSibling","addInertStyle","querySelector","style","document","createElement","setAttribute","textContent","appendChild","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","slice","Array","_focusableElementsString","join","InertRoot","rootElement","inertManager","this","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","disconnect","hasSavedAriaHidden","savedAriaHidden","removeAttribute","forEach","inertNode","_unmanageNode","startNode","_this","_visitNode","activeElement","body","contains","root","undefined","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","_adoptInertRoot","matches","_manageNode","register","add","deregister","_this2","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","call","addedNodes","removedNodes","_unmanageSubtree","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_destroyed","ensureUntabbable","_throwIfDestroyed","hasSavedTabIndex","savedTabIndex","destroyed","Error","tabIndex","_savedTabIndex","size","destructor","InertManager","_document","Map","_watchForInert","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","addInertRoot","removeInertRoot","inertElements","querySelectorAll","inertElement","unshift","Element","toggleNavigation","nav","currentElement","classList","remove","ctas","mainNavigation","el","currentCta"],"mappings":"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","file":"scriptsBundleMain.js","sourcesContent":["/**\r\n * This work is licensed under the W3C Software and Document License\r\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\r\n */\r\n\r\n// Convenience function for converting NodeLists.\r\n/** @type {function(number,number):Array} */\r\nconst slice = Array.prototype.slice;\r\n\r\n/** @type {string} */\r\nconst _focusableElementsString = ['a[href]',\r\n                                  'area[href]',\r\n                                  'input:not([disabled])',\r\n                                  'select:not([disabled])',\r\n                                  'textarea:not([disabled])',\r\n                                  'button:not([disabled])',\r\n                                  'iframe',\r\n                                  'object',\r\n                                  'embed',\r\n                                  '[contenteditable]'].join(',');\r\n\r\n/**\r\n * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\r\n * attribute.\r\n *\r\n * Its main functions are:\r\n *\r\n * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\r\n *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\r\n *   each focusable node in the subtree with the singleton `InertManager` which manages all known\r\n *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\r\n *   instance exists for each focusable node which has at least one inert root as an ancestor.\r\n *\r\n * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\r\n *   attribute is removed from the root node). This is handled in the destructor, which calls the\r\n *   `deregister` method on `InertManager` for each managed inert node.\r\n */\r\nclass InertRoot {\r\n  /**\r\n   * @param {Element} rootElement The Element at the root of the inert subtree.\r\n   * @param {InertManager} inertManager The global singleton InertManager object.\r\n   */\r\n  constructor(rootElement, inertManager) {\r\n    /** @type {InertManager} */\r\n    this._inertManager = inertManager;\r\n\r\n    /** @type {Element} */\r\n    this._rootElement = rootElement;\r\n\r\n    /**\r\n     * @type {Set<Node>}\r\n     * All managed focusable nodes in this InertRoot's subtree.\r\n     */\r\n    this._managedNodes = new Set([]);\r\n\r\n    // Make the subtree hidden from assistive technology\r\n    if (this._rootElement.hasAttribute('aria-hidden')) {\r\n      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\r\n    }\r\n    this._rootElement.setAttribute('aria-hidden', 'true');\r\n\r\n    // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\r\n    this._makeSubtreeUnfocusable(this._rootElement);\r\n\r\n    // Watch for:\r\n    // - any additions in the subtree: make them unfocusable too\r\n    // - any removals from the subtree: remove them from this inert root's managed nodes\r\n    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\r\n    //   element, make that node a managed node.\r\n    this._observer = new MutationObserver(this._onMutation.bind(this));\r\n    this._observer.observe(this._rootElement, {attributes: true, childList: true, subtree: true});\r\n  }\r\n\r\n  /**\r\n   * Call this whenever this object is about to become obsolete.  This unwinds all of the state\r\n   * stored in this object and updates the state of all of the managed nodes.\r\n   */\r\n  destructor() {\r\n    this._observer.disconnect();\r\n    this._observer = null;\r\n\r\n    if (this._rootElement) {\r\n      if (this.hasSavedAriaHidden) {\r\n        this._rootElement.setAttribute('aria-hidden', this.savedAriaHidden);\r\n      } else {\r\n        this._rootElement.removeAttribute('aria-hidden');\r\n      }\r\n    }\r\n    this._rootElement = null;\r\n\r\n    this._managedNodes.forEach(function(inertNode) {\r\n      this._unmanageNode(inertNode.node);\r\n    }, this);\r\n\r\n    this._managedNodes = null;\r\n\r\n    this._inertManager = null;\r\n  }\r\n\r\n  /**\r\n   * @return {Set<InertNode>} A copy of this InertRoot's managed nodes set.\r\n   */\r\n  get managedNodes() {\r\n    return new Set(this._managedNodes);\r\n  }\r\n\r\n  /** @return {boolean} */\r\n  get hasSavedAriaHidden() {\r\n    return '_savedAriaHidden' in this;\r\n  }\r\n\r\n  /** @param {string} ariaHidden */\r\n  set savedAriaHidden(ariaHidden) {\r\n    this._savedAriaHidden = ariaHidden;\r\n  }\r\n\r\n  /** @return {string} */\r\n  get savedAriaHidden() {\r\n    return this._savedAriaHidden;\r\n  }\r\n\r\n  /**\r\n   * @param {Node} startNode\r\n   */\r\n  _makeSubtreeUnfocusable(startNode) {\r\n    composedTreeWalk(startNode, (node) => this._visitNode(node));\r\n\r\n    let activeElement = document.activeElement;\r\n\r\n    if (!document.body.contains(startNode)) {\r\n      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\r\n      let node = startNode;\r\n      let root = undefined;\r\n      while (node) {\r\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n          root = node;\r\n          break;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      if (root) {\r\n        activeElement = root.activeElement;\r\n      }\r\n    }\r\n    if (startNode.contains(activeElement)) {\r\n      activeElement.blur();\r\n      // In IE11, if an element is already focused, and then set to tabindex=-1\r\n      // calling blur() will not actually move the focus.\r\n      // To work around this we call focus() on the body instead.\r\n      if (activeElement === document.activeElement) {\r\n        document.body.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  _visitNode(node) {\r\n    if (node.nodeType !== Node.ELEMENT_NODE) {\r\n      return;\r\n    }\r\n\r\n    // If a descendant inert root becomes un-inert, its descendants will still be inert because of\r\n    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\r\n    if (node !== this._rootElement && node.hasAttribute('inert')) {\r\n      this._adoptInertRoot(node);\r\n    }\r\n\r\n    if (node.matches(_focusableElementsString) || node.hasAttribute('tabindex')) {\r\n      this._manageNode(node);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register the given node with this InertRoot and with InertManager.\r\n   * @param {Node} node\r\n   */\r\n  _manageNode(node) {\r\n    const inertNode = this._inertManager.register(node, this);\r\n    this._managedNodes.add(inertNode);\r\n  }\r\n\r\n  /**\r\n   * Unregister the given node with this InertRoot and with InertManager.\r\n   * @param {Node} node\r\n   */\r\n  _unmanageNode(node) {\r\n    const inertNode = this._inertManager.deregister(node, this);\r\n    if (inertNode) {\r\n      this._managedNodes.delete(inertNode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unregister the entire subtree starting at `startNode`.\r\n   * @param {Node} startNode\r\n   */\r\n  _unmanageSubtree(startNode) {\r\n    composedTreeWalk(startNode, (node) => this._unmanageNode(node));\r\n  }\r\n\r\n  /**\r\n   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\r\n   * @param {Node} node\r\n   */\r\n  _adoptInertRoot(node) {\r\n    let inertSubroot = this._inertManager.getInertRoot(node);\r\n\r\n    // During initialisation this inert root may not have been registered yet,\r\n    // so register it now if need be.\r\n    if (!inertSubroot) {\r\n      this._inertManager.setInert(node, true);\r\n      inertSubroot = this._inertManager.getInertRoot(node);\r\n    }\r\n\r\n    inertSubroot.managedNodes.forEach(function(savedInertNode) {\r\n      this._manageNode(savedInertNode.node);\r\n    }, this);\r\n  }\r\n\r\n  /**\r\n   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\r\n   * @param {MutationRecord} records\r\n   * @param {MutationObserver} self\r\n   */\r\n  _onMutation(records, self) {\r\n    records.forEach(function(record) {\r\n      const target = record.target;\r\n      if (record.type === 'childList') {\r\n        // Manage added nodes\r\n        slice.call(record.addedNodes).forEach(function(node) {\r\n          this._makeSubtreeUnfocusable(node);\r\n        }, this);\r\n\r\n        // Un-manage removed nodes\r\n        slice.call(record.removedNodes).forEach(function(node) {\r\n          this._unmanageSubtree(node);\r\n        }, this);\r\n      } else if (record.type === 'attributes') {\r\n        if (record.attributeName === 'tabindex') {\r\n          // Re-initialise inert node if tabindex changes\r\n          this._manageNode(target);\r\n        } else if (target !== this._rootElement &&\r\n                   record.attributeName === 'inert' &&\r\n                   target.hasAttribute('inert')) {\r\n          // If a new inert root is added, adopt its managed nodes and make sure it knows about the\r\n          // already managed nodes from this inert subroot.\r\n          this._adoptInertRoot(target);\r\n          const inertSubroot = this._inertManager.getInertRoot(target);\r\n          this._managedNodes.forEach(function(managedNode) {\r\n            if (target.contains(managedNode.node)) {\r\n              inertSubroot._manageNode(managedNode.node);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }, this);\r\n  }\r\n}\r\n\r\n/**\r\n * `InertNode` initialises and manages a single inert node.\r\n * A node is inert if it is a descendant of one or more inert root elements.\r\n *\r\n * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\r\n * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\r\n * is intrinsically focusable or not.\r\n *\r\n * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\r\n * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\r\n * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\r\n * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\r\n * or removes the `tabindex` attribute if the element is intrinsically focusable.\r\n */\r\nclass InertNode {\r\n  /**\r\n   * @param {Node} node A focusable element to be made inert.\r\n   * @param {InertRoot} inertRoot The inert root element associated with this inert node.\r\n   */\r\n  constructor(node, inertRoot) {\r\n    /** @type {Node} */\r\n    this._node = node;\r\n\r\n    /** @type {boolean} */\r\n    this._overrodeFocusMethod = false;\r\n\r\n    /**\r\n     * @type {Set<InertRoot>} The set of descendant inert roots.\r\n     *    If and only if this set becomes empty, this node is no longer inert.\r\n     */\r\n    this._inertRoots = new Set([inertRoot]);\r\n\r\n    /** @type {boolean} */\r\n    this._destroyed = false;\r\n\r\n    // Save any prior tabindex info and make this node untabbable\r\n    this.ensureUntabbable();\r\n  }\r\n\r\n  /**\r\n   * Call this whenever this object is about to become obsolete.\r\n   * This makes the managed node focusable again and deletes all of the previously stored state.\r\n   */\r\n  destructor() {\r\n    this._throwIfDestroyed();\r\n\r\n    if (this._node) {\r\n      if (this.hasSavedTabIndex) {\r\n        this._node.setAttribute('tabindex', this.savedTabIndex);\r\n      } else {\r\n        this._node.removeAttribute('tabindex');\r\n      }\r\n\r\n      // Use `delete` to restore native focus method.\r\n      if (this._overrodeFocusMethod) {\r\n        delete this._node.focus;\r\n      }\r\n    }\r\n    this._node = null;\r\n    this._inertRoots = null;\r\n\r\n    this._destroyed = true;\r\n  }\r\n\r\n  /**\r\n   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\r\n   * If the object has been destroyed, any attempt to access it will cause an exception.\r\n   */\r\n  get destroyed() {\r\n    return this._destroyed;\r\n  }\r\n\r\n  /**\r\n   * Throw if user tries to access destroyed InertNode.\r\n   */\r\n  _throwIfDestroyed() {\r\n    if (this.destroyed) {\r\n      throw new Error('Trying to access destroyed InertNode');\r\n    }\r\n  }\r\n\r\n  /** @return {boolean} */\r\n  get hasSavedTabIndex() {\r\n    return '_savedTabIndex' in this;\r\n  }\r\n\r\n  /** @return {Node} */\r\n  get node() {\r\n    this._throwIfDestroyed();\r\n    return this._node;\r\n  }\r\n\r\n  /** @param {number} tabIndex */\r\n  set savedTabIndex(tabIndex) {\r\n    this._throwIfDestroyed();\r\n    this._savedTabIndex = tabIndex;\r\n  }\r\n\r\n  /** @return {number} */\r\n  get savedTabIndex() {\r\n    this._throwIfDestroyed();\r\n    return this._savedTabIndex;\r\n  }\r\n\r\n  /** Save the existing tabindex value and make the node untabbable and unfocusable */\r\n  ensureUntabbable() {\r\n    const node = this.node;\r\n    if (node.matches(_focusableElementsString)) {\r\n      if (node.tabIndex === -1 && this.hasSavedTabIndex) {\r\n        return;\r\n      }\r\n\r\n      if (node.hasAttribute('tabindex')) {\r\n        this._savedTabIndex = node.tabIndex;\r\n      }\r\n      node.setAttribute('tabindex', '-1');\r\n      if (node.nodeType === Node.ELEMENT_NODE) {\r\n        node.focus = function() {};\r\n        this._overrodeFocusMethod = true;\r\n      }\r\n    } else if (node.hasAttribute('tabindex')) {\r\n      this._savedTabIndex = node.tabIndex;\r\n      node.removeAttribute('tabindex');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add another inert root to this inert node's set of managing inert roots.\r\n   * @param {InertRoot} inertRoot\r\n   */\r\n  addInertRoot(inertRoot) {\r\n    this._throwIfDestroyed();\r\n    this._inertRoots.add(inertRoot);\r\n  }\r\n\r\n  /**\r\n   * Remove the given inert root from this inert node's set of managing inert roots.\r\n   * If the set of managing inert roots becomes empty, this node is no longer inert,\r\n   * so the object should be destroyed.\r\n   * @param {InertRoot} inertRoot\r\n   */\r\n  removeInertRoot(inertRoot) {\r\n    this._throwIfDestroyed();\r\n    this._inertRoots.delete(inertRoot);\r\n    if (this._inertRoots.size === 0) {\r\n      this.destructor();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * InertManager is a per-document singleton object which manages all inert roots and nodes.\r\n *\r\n * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\r\n * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\r\n * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\r\n * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\r\n * is created for each such node, via the `_managedNodes` map.\r\n */\r\nclass InertManager {\r\n  /**\r\n   * @param {Document} document\r\n   */\r\n  constructor(document) {\r\n    if (!document) {\r\n      throw new Error('Missing required argument; InertManager needs to wrap a document.');\r\n    }\r\n\r\n    /** @type {Document} */\r\n    this._document = document;\r\n\r\n    /**\r\n     * All managed nodes known to this InertManager. In a map to allow looking up by Node.\r\n     * @type {Map<Node, InertNode>}\r\n     */\r\n    this._managedNodes = new Map();\r\n\r\n    /**\r\n     * All inert roots known to this InertManager. In a map to allow looking up by Node.\r\n     * @type {Map<Node, InertRoot>}\r\n     */\r\n    this._inertRoots = new Map();\r\n\r\n    /**\r\n     * Observer for mutations on `document.body`.\r\n     * @type {MutationObserver}\r\n     */\r\n    this._observer = new MutationObserver(this._watchForInert.bind(this));\r\n\r\n\r\n    // Add inert style.\r\n    addInertStyle(document.head || document.body || document.documentElement);\r\n\r\n    // Wait for document to be loaded.\r\n    if (document.readyState === 'loading') {\r\n      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\r\n    } else {\r\n      this._onDocumentLoaded();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set whether the given element should be an inert root or not.\r\n   * @param {Element} root\r\n   * @param {boolean} inert\r\n   */\r\n  setInert(root, inert) {\r\n    if (inert) {\r\n      if (this._inertRoots.has(root)) { // element is already inert\r\n        return;\r\n      }\r\n\r\n      const inertRoot = new InertRoot(root, this);\r\n      root.setAttribute('inert', '');\r\n      this._inertRoots.set(root, inertRoot);\r\n      // If not contained in the document, it must be in a shadowRoot.\r\n      // Ensure inert styles are added there.\r\n      if (!this._document.body.contains(root)) {\r\n        let parent = root.parentNode;\r\n        while (parent) {\r\n          if (parent.nodeType === 11) {\r\n            addInertStyle(parent);\r\n          }\r\n          parent = parent.parentNode;\r\n        }\r\n      }\r\n    } else {\r\n      if (!this._inertRoots.has(root)) { // element is already non-inert\r\n        return;\r\n      }\r\n\r\n      const inertRoot = this._inertRoots.get(root);\r\n      inertRoot.destructor();\r\n      this._inertRoots.delete(root);\r\n      root.removeAttribute('inert');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the InertRoot object corresponding to the given inert root element, if any.\r\n   * @param {Element} element\r\n   * @return {InertRoot?}\r\n   */\r\n  getInertRoot(element) {\r\n    return this._inertRoots.get(element);\r\n  }\r\n\r\n  /**\r\n   * Register the given InertRoot as managing the given node.\r\n   * In the case where the node has a previously existing inert root, this inert root will\r\n   * be added to its set of inert roots.\r\n   * @param {Node} node\r\n   * @param {InertRoot} inertRoot\r\n   * @return {InertNode} inertNode\r\n   */\r\n  register(node, inertRoot) {\r\n    let inertNode = this._managedNodes.get(node);\r\n    if (inertNode !== undefined) { // node was already in an inert subtree\r\n      inertNode.addInertRoot(inertRoot);\r\n    } else {\r\n      inertNode = new InertNode(node, inertRoot);\r\n    }\r\n\r\n    this._managedNodes.set(node, inertNode);\r\n\r\n    return inertNode;\r\n  }\r\n\r\n  /**\r\n   * De-register the given InertRoot as managing the given inert node.\r\n   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\r\n   * node from the InertManager's set of managed nodes if it is destroyed.\r\n   * If the node is not currently managed, this is essentially a no-op.\r\n   * @param {Node} node\r\n   * @param {InertRoot} inertRoot\r\n   * @return {InertNode?} The potentially destroyed InertNode associated with this node, if any.\r\n   */\r\n  deregister(node, inertRoot) {\r\n    const inertNode = this._managedNodes.get(node);\r\n    if (!inertNode) {\r\n      return null;\r\n    }\r\n\r\n    inertNode.removeInertRoot(inertRoot);\r\n    if (inertNode.destroyed) {\r\n      this._managedNodes.delete(node);\r\n    }\r\n\r\n    return inertNode;\r\n  }\r\n\r\n  /**\r\n   * Callback used when document has finished loading.\r\n   */\r\n  _onDocumentLoaded() {\r\n    // Find all inert roots in document and make them actually inert.\r\n    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));\r\n    inertElements.forEach(function(inertElement) {\r\n      this.setInert(inertElement, true);\r\n    }, this);\r\n\r\n    // Comment this out to use programmatic API only.\r\n    this._observer.observe(this._document.body, {attributes: true, subtree: true, childList: true});\r\n  }\r\n\r\n  /**\r\n   * Callback used when mutation observer detects attribute changes.\r\n   * @param {MutationRecord} records\r\n   * @param {MutationObserver} self\r\n   */\r\n  _watchForInert(records, self) {\r\n    records.forEach(function(record) {\r\n      switch (record.type) {\r\n      case 'childList':\r\n        slice.call(record.addedNodes).forEach(function(node) {\r\n          if (node.nodeType !== Node.ELEMENT_NODE) {\r\n            return;\r\n          }\r\n          const inertElements = slice.call(node.querySelectorAll('[inert]'));\r\n          if (node.matches('[inert]')) {\r\n            inertElements.unshift(node);\r\n          }\r\n          inertElements.forEach(function(inertElement) {\r\n            this.setInert(inertElement, true);\r\n          }, this);\r\n        }, this);\r\n        break;\r\n      case 'attributes':\r\n        if (record.attributeName !== 'inert') {\r\n          return;\r\n        }\r\n        const target = record.target;\r\n        const inert = target.hasAttribute('inert');\r\n        this.setInert(target, inert);\r\n        break;\r\n      }\r\n    }, this);\r\n  }\r\n}\r\n\r\n /**\r\n  * Recursively walk the composed tree from |node|.\r\n  * @param {Node} node\r\n  * @param {(function (Element))=} callback Callback to be called for each element traversed,\r\n  *     before descending into child nodes.\r\n  * @param {ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\r\n  */\r\nfunction composedTreeWalk(node, callback, shadowRootAncestor) {\r\n  if (node.nodeType == Node.ELEMENT_NODE) {\r\n    const element = /** @type {Element} */ (node);\r\n    if (callback) {\r\n      callback(element);\r\n    }\r\n\r\n    // Descend into node:\r\n    // If it has a ShadowRoot, ignore all child elements - these will be picked\r\n    // up by the <content> or <shadow> elements. Descend straight into the\r\n    // ShadowRoot.\r\n    const shadowRoot = element.shadowRoot || element.webkitShadowRoot;\r\n    if (shadowRoot) {\r\n      composedTreeWalk(shadowRoot, callback, shadowRoot);\r\n      return;\r\n    }\r\n\r\n    // If it is a <content> element, descend into distributed elements - these\r\n    // are elements from outside the shadow root which are rendered inside the\r\n    // shadow DOM.\r\n    if (element.localName == 'content') {\r\n      const content = /** @type {HTMLContentElement} */ (element);\r\n      // Verifies if ShadowDom v0 is supported.\r\n      const distributedNodes = content.getDistributedNodes ?\r\n        content.getDistributedNodes() : [];\r\n      for (let i = 0; i < distributedNodes.length; i++) {\r\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // If it is a <slot> element, descend into assigned nodes - these\r\n    // are elements from outside the shadow root which are rendered inside the\r\n    // shadow DOM.\r\n    if (element.localName == 'slot') {\r\n      const slot = /** @type {HTMLSlotElement} */ (element);\r\n      // Verify if ShadowDom v1 is supported.\r\n      const distributedNodes = slot.assignedNodes ?\r\n        slot.assignedNodes({flatten: true}) : [];\r\n      for (let i = 0; i < distributedNodes.length; i++) {\r\n        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\r\n  // element, nor a <shadow> element recurse normally.\r\n  let child = node.firstChild;\r\n  while (child != null) {\r\n    composedTreeWalk(child, callback, shadowRootAncestor);\r\n    child = child.nextSibling;\r\n  }\r\n}\r\n\r\n/**\r\n * Adds a style element to the node containing the inert specific styles\r\n * @param {Node} node\r\n */\r\nfunction addInertStyle(node) {\r\n  if (node.querySelector('style#inert-style')) {\r\n    return;\r\n  }\r\n  const style = document.createElement('style');\r\n  style.setAttribute('id', 'inert-style');\r\n  style.textContent = '\\n'+\r\n                      '[inert] {\\n' +\r\n                      '  pointer-events: none;\\n' +\r\n                      '  cursor: default;\\n' +\r\n                      '}\\n' +\r\n                      '\\n' +\r\n                      '[inert], [inert] * {\\n' +\r\n                      '  user-select: none;\\n' +\r\n                      '  -webkit-user-select: none;\\n' +\r\n                      '  -moz-user-select: none;\\n' +\r\n                      '  -ms-user-select: none;\\n' +\r\n                      '}\\n';\r\n  node.appendChild(style);\r\n}\r\n\r\nconst inertManager = new InertManager(document);\r\n\r\nObject.defineProperty(Element.prototype, 'inert', {\r\n                        enumerable: true,\r\n                        get: function() {\r\n                          return this.hasAttribute('inert');\r\n                        },\r\n                        set: function(inert) {\r\n                          inertManager.setInert(this, inert);\r\n                        },\r\n                      });\r\n","(function () {\r\n  document.addEventListener(\"DOMContentLoaded\", function () {\r\n      var ctas = document.querySelectorAll(\"button.burger\");\r\n      var mainNavigation = document.querySelector('#main-navigation');\r\n\r\n      Array.prototype.forEach.call(ctas, function (el, i) {\r\n          var currentCta = ctas[i];\r\n\r\n          //Event handler 1 for exemple click\r\n          currentCta.addEventListener(\"click\", function () {\r\n            toggleNavigation(mainNavigation, currentCta);\r\n          });\r\n      });\r\n\r\n  });\r\n\r\n  function toggleNavigation(nav, currentElement) {\r\n      if (currentElement.classList.contains('is-open')){\r\n        currentElement.classList.remove('is-open');\r\n        nav.classList.remove('is-open');\r\n        nav.inert = true;\r\n      } else {\r\n        currentElement.classList.add('is-open');\r\n        nav.classList.add('is-open');\r\n        nav.inert = false;\r\n      }\r\n  }\r\n})();"],"sourceRoot":"/source/"}